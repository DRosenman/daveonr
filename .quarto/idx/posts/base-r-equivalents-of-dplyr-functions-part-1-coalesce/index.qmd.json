{"title":"Base R Equivalents of dplyr Functions Part 1 - coalesce","markdown":{"yaml":{"title":"Base R Equivalents of dplyr Functions Part 1 - coalesce","author":"Dave Rosenman","date":"2024-05-16","categories":["R","code","tidyverse","dplyr"]},"headingText":"Example usage:","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(message = FALSE)\n```\n\nThe dplyr `coalesce` function is incredibly useful and similar to the SQL `COALESCE` function. Given a set of vectors, it finds and keeps the first non-`NA` value at each position. For example, the following code returns the vector c(1, 2, 3, 4).\n\n```{r}\n\nlibrary(dplyr)\ncoalesce(c(1, NA, 3, NA), c(2, 2, 4, 4))\n```\n\n* At position 1, the first non-`NA` value is 1 (from the first vector).\n* At position 2, the first non-`NA` value is 2 (from the second vector, because the value at position 2 in the first vector is NA).\n* At position 3, the first non-`NA` value is 3 (from the first vector).\n* Finally, at position 4, the first non-`NA` value is 4 (from the second vector, because the value at position 4 in the first vector is NA).\n\nThe `coalesce` function is not limited to two vectors. You can use as many vectors as you'd like.\n\n```{r}\ncoalesce(c(1, 2, NA, NA), c(3, 3, 3, NA), c(4, 4, 4, 4))\n```\n\nThe vectors must be of equal length or length 1. Vectors of length 1 will be recycled. The following:\n\n```{r}\ncoalesce(c(1, NA, NA, 5), 3)\n```\n\nIs equivalent to:\n\n```{r}\ndplyr::coalesce(c(1, NA, NA, 5), c(3, 3, 3, 3))\n```\n\nI most often use `coalesce` to replace all `NA` values in a vector with a single value. For example, the following code replaces all `NA` values with 0:\n\n```{r}\ncoalesce(c(1, NA, NA, 5, 6), 0)\n```\n\nHere are two alternative ways to do the same thing.\n\n```{r}\nlibrary(tidyr)\nreplace_na(c(1, NA, NA, 5, 6), 0) # this function is in the tidyr package\n```\n\n```{r}\nx <- c(1, NA, NA, 5, 6)\nifelse(is.na(x), 0, x)\n```\n\nOf the three options I have shown so far, I prefer `coalesce` and `replace_na`. (`coalesce` is a more general version of `replace_na`; `replace_na` takes a vector and a single value to replace the `NA` values in that vector with). If you want to go outside of base R and the tidyverse, `data.table::fcoalesce` is a much faster version of `dplyr::coalesce`.\n\nLet's compare the speeds!\n\n```{r}\nlibrary(microbenchmark)\nlibrary(data.table)\nset.seed(11)\nx <- 1:10^7\nx[sample(1:10^7, size = 10^6, replace = FALSE)] <- NA\nmicrobenchmark(\n  fcoalesce(x, 0L),\n  coalesce(x, 0L),\n  replace_na(x, 0L),\n  ifelse(is.na(x), 0L, x),\n  times = 5\n  )\n```\n\n`data.table:fcoalesce` is the winner in terms of speed, followed by `replace_na`. Of the four methods above, `coalesce` and `fcoalesce` are the most general, since they are not limited to replacing all `NA` values with a single value.\n\nIs there a base R equivalent to `dplyr::coalesce`? No. But we can easily create one using just base R code.\n\nTo think about how we would do that, let's start with two vectors:\n\n```{r}\nx <- c(1, 2, NA, NA)\ny <- c(2, 2, 3, NA)\ncoalesce(x, y)\n```\n\nHow could we get the same results using the `ifelse` function? It's simple. We return the value in `y` when the value in `x` is `NA`.\n\n```{r}\nifelse(is.na(x), y, x)\n```\n\nThat's simple enough. But what if we want to use three vectors?\n\n```{r}\nz <- c(4, 4, 4, 4)\ncoalesce(x, y, z)\n```\n\nWe can start with our code from the case where we used two vectors.\n\n```{r}\noutput_step_1 <- ifelse(is.na(x), y, x)\n```\n\nWhen both `x` and `y` are `NA` (when `ifelse(is.na(x), y, x)` gives us `NA`), we want to use what is in z. Otherwise, we want to keep the results from step 1 above.\n\n```{r}\nifelse(is.na(output_step_1), z, output_step_1)\n```\n\nThat worked! But what if we want to generalize this to any number of input vectors? We can use the base R function `Reduce`. For our case where we used `x`, `y`, and `z`, we could do:\n\n```{r}\n Reduce(function(x, y) ifelse(is.na(x), y, x), list(x, y, z))\n\n```\n\n`Reduce(f, list(x, y, z))`, where `f` is a function of two variables, is the equivalent of `f(f(x, y), z)`. And `Reduce(f, list(x, y, z, a))` is equivalent to `f(f(f(x, y), z), a)`. The Reduce function is used to iteratively apply a function to elements of a list, reducing it to a single value. It takes a function with two parameters and applies it to the first two elements of the list, then applies the same function to the result and the next element, and so on, until all elements are combined into a single value.\n\nTo use `Reduce` to mimic `coalesce(x, y, z, ...)`, we need to apply the logic `f <- function(x, y) { ifelse(is.na(x), y, x)}` over and over starting from left to right. In other words, for three vectors x, y, and z, we need to do:\n\n```{r}\nf <- function(x, y) {\n  ifelse(is.na(x), y, x)\n}\nf(f(x, y), z)\n\n\n```\n\nWhich is equivalent to\n\n```{r}\nReduce(f, list(x, y, z))\n```\n\nSo a very simple base R function equivalent to the `coalesce` function is:\n\n```{r}\ncoalesce_base_r <- function(...) {\n  args <- list(...)\n  Reduce(function(x, y) ifelse(is.na(x), y, x), args)\n}\n```\n\nLet's see if it produces identical results to `dplyr::coalesce`:\n\n```{r}\nset.seed(11)\nx <- 1:10^7\ny <- 1:10^7\nx[sample(1:10^7, size = 10^6, replace = FALSE)] <- NA\ny[sample(1:10^7, size = 10^6, replace = FALSE)] <- NA\nz <- 1L\n\ndplyr_result <- coalesce(x, y, z)\nbase_r_result <- coalesce_base_r(x, y, z)\nidentical(dplyr_result, base_r_result)\n\n\n```\n\nWe get identical results!\n\nLet's compare the speed:\n\n```{r}\nmicrobenchmark(coalesce(x, y, z), coalesce_base_r(x, y, z), times = 5)\n```\n\nOur base R version of `coalesce` is almost identical in speed dplyr's!\n\nBut our function contains some flaws. dplyr's `coalesce` function forces the vectors passed to it to either be of the same length or be of length 1. If we try:\n\n```{r}\n#| error: true\ncoalesce(c(1, 2, 3, NA, 6), c(4, 5))\n```\n\nWe get an error, since the first vector has length 5 and the second has length 2.\n\n\nHere's a better base R version of `coalesce`:\n\n```{r}\ncoalesce_base <- function(...) {\n  args <- list(...)\n  \n  # Check for NULL, zero-length vectors, and collect lengths\n  lengths <- sapply(args, function(x) {\n    if (is.null(x) || length(x) == 0) {\n      stop(\"Arguments must not be NULL or zero-length vectors\")\n    }\n    length(x)\n  })\n  \n  # Determine the maximum length\n  max_length <- max(lengths)\n  \n  # Check if lengths are consistent. \n  # Only allow vectors of length equal to max length or length of 1\n  if (any(lengths != max_length & lengths != 1)) {\n    stop(\"All arguments must have the same length, \n         except for vectors of length 1 which can be recycled\")\n  }\n  \n  # Use Reduce with ifelse to coalesce\n  Reduce(function(x, y) ifelse(is.na(x), y, x), args)\n}\n\nv1 <- c(NA, 2, NA, 4, NA)\nv2 <- c(1, NA, 3, NA, NA)\nv3 <- 0\n\ncoalesce_base(v1, v2, v3)\n```\n\nAgain, let's compare the speed of our function to `dplyr::coalesce` and `data.table::fcoalesce`.\n\n```{r}\nmicrobenchmark(fcoalesce(x, y, z),\n               coalesce(x, y, z), \n               coalesce_base_r(x, y, z), \n               times = 5)\n```\n\n`data.table::fcoalesce` is the clear winner when it comes to speed! Our function is almost identical in speed to `dplyr::coalesce`! \n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(message = FALSE)\n```\n\nThe dplyr `coalesce` function is incredibly useful and similar to the SQL `COALESCE` function. Given a set of vectors, it finds and keeps the first non-`NA` value at each position. For example, the following code returns the vector c(1, 2, 3, 4).\n\n```{r}\n\nlibrary(dplyr)\ncoalesce(c(1, NA, 3, NA), c(2, 2, 4, 4))\n```\n\n* At position 1, the first non-`NA` value is 1 (from the first vector).\n* At position 2, the first non-`NA` value is 2 (from the second vector, because the value at position 2 in the first vector is NA).\n* At position 3, the first non-`NA` value is 3 (from the first vector).\n* Finally, at position 4, the first non-`NA` value is 4 (from the second vector, because the value at position 4 in the first vector is NA).\n\nThe `coalesce` function is not limited to two vectors. You can use as many vectors as you'd like.\n\n```{r}\ncoalesce(c(1, 2, NA, NA), c(3, 3, 3, NA), c(4, 4, 4, 4))\n```\n\nThe vectors must be of equal length or length 1. Vectors of length 1 will be recycled. The following:\n\n```{r}\ncoalesce(c(1, NA, NA, 5), 3)\n```\n\nIs equivalent to:\n\n```{r}\ndplyr::coalesce(c(1, NA, NA, 5), c(3, 3, 3, 3))\n```\n\nI most often use `coalesce` to replace all `NA` values in a vector with a single value. For example, the following code replaces all `NA` values with 0:\n\n```{r}\ncoalesce(c(1, NA, NA, 5, 6), 0)\n```\n\nHere are two alternative ways to do the same thing.\n\n```{r}\nlibrary(tidyr)\nreplace_na(c(1, NA, NA, 5, 6), 0) # this function is in the tidyr package\n```\n\n```{r}\nx <- c(1, NA, NA, 5, 6)\nifelse(is.na(x), 0, x)\n```\n\nOf the three options I have shown so far, I prefer `coalesce` and `replace_na`. (`coalesce` is a more general version of `replace_na`; `replace_na` takes a vector and a single value to replace the `NA` values in that vector with). If you want to go outside of base R and the tidyverse, `data.table::fcoalesce` is a much faster version of `dplyr::coalesce`.\n\nLet's compare the speeds!\n\n```{r}\nlibrary(microbenchmark)\nlibrary(data.table)\nset.seed(11)\nx <- 1:10^7\nx[sample(1:10^7, size = 10^6, replace = FALSE)] <- NA\nmicrobenchmark(\n  fcoalesce(x, 0L),\n  coalesce(x, 0L),\n  replace_na(x, 0L),\n  ifelse(is.na(x), 0L, x),\n  times = 5\n  )\n```\n\n`data.table:fcoalesce` is the winner in terms of speed, followed by `replace_na`. Of the four methods above, `coalesce` and `fcoalesce` are the most general, since they are not limited to replacing all `NA` values with a single value.\n\nIs there a base R equivalent to `dplyr::coalesce`? No. But we can easily create one using just base R code.\n\nTo think about how we would do that, let's start with two vectors:\n\n```{r}\nx <- c(1, 2, NA, NA)\ny <- c(2, 2, 3, NA)\ncoalesce(x, y)\n```\n\nHow could we get the same results using the `ifelse` function? It's simple. We return the value in `y` when the value in `x` is `NA`.\n\n```{r}\nifelse(is.na(x), y, x)\n```\n\nThat's simple enough. But what if we want to use three vectors?\n\n```{r}\nz <- c(4, 4, 4, 4)\ncoalesce(x, y, z)\n```\n\nWe can start with our code from the case where we used two vectors.\n\n```{r}\noutput_step_1 <- ifelse(is.na(x), y, x)\n```\n\nWhen both `x` and `y` are `NA` (when `ifelse(is.na(x), y, x)` gives us `NA`), we want to use what is in z. Otherwise, we want to keep the results from step 1 above.\n\n```{r}\nifelse(is.na(output_step_1), z, output_step_1)\n```\n\nThat worked! But what if we want to generalize this to any number of input vectors? We can use the base R function `Reduce`. For our case where we used `x`, `y`, and `z`, we could do:\n\n```{r}\n Reduce(function(x, y) ifelse(is.na(x), y, x), list(x, y, z))\n\n```\n\n`Reduce(f, list(x, y, z))`, where `f` is a function of two variables, is the equivalent of `f(f(x, y), z)`. And `Reduce(f, list(x, y, z, a))` is equivalent to `f(f(f(x, y), z), a)`. The Reduce function is used to iteratively apply a function to elements of a list, reducing it to a single value. It takes a function with two parameters and applies it to the first two elements of the list, then applies the same function to the result and the next element, and so on, until all elements are combined into a single value.\n\nTo use `Reduce` to mimic `coalesce(x, y, z, ...)`, we need to apply the logic `f <- function(x, y) { ifelse(is.na(x), y, x)}` over and over starting from left to right. In other words, for three vectors x, y, and z, we need to do:\n\n```{r}\nf <- function(x, y) {\n  ifelse(is.na(x), y, x)\n}\nf(f(x, y), z)\n\n\n```\n\nWhich is equivalent to\n\n```{r}\nReduce(f, list(x, y, z))\n```\n\nSo a very simple base R function equivalent to the `coalesce` function is:\n\n```{r}\ncoalesce_base_r <- function(...) {\n  args <- list(...)\n  Reduce(function(x, y) ifelse(is.na(x), y, x), args)\n}\n```\n\nLet's see if it produces identical results to `dplyr::coalesce`:\n\n```{r}\nset.seed(11)\nx <- 1:10^7\ny <- 1:10^7\nx[sample(1:10^7, size = 10^6, replace = FALSE)] <- NA\ny[sample(1:10^7, size = 10^6, replace = FALSE)] <- NA\nz <- 1L\n\ndplyr_result <- coalesce(x, y, z)\nbase_r_result <- coalesce_base_r(x, y, z)\nidentical(dplyr_result, base_r_result)\n\n\n```\n\nWe get identical results!\n\nLet's compare the speed:\n\n```{r}\nmicrobenchmark(coalesce(x, y, z), coalesce_base_r(x, y, z), times = 5)\n```\n\nOur base R version of `coalesce` is almost identical in speed dplyr's!\n\nBut our function contains some flaws. dplyr's `coalesce` function forces the vectors passed to it to either be of the same length or be of length 1. If we try:\n\n```{r}\n#| error: true\ncoalesce(c(1, 2, 3, NA, 6), c(4, 5))\n```\n\nWe get an error, since the first vector has length 5 and the second has length 2.\n\n\nHere's a better base R version of `coalesce`:\n\n```{r}\ncoalesce_base <- function(...) {\n  args <- list(...)\n  \n  # Check for NULL, zero-length vectors, and collect lengths\n  lengths <- sapply(args, function(x) {\n    if (is.null(x) || length(x) == 0) {\n      stop(\"Arguments must not be NULL or zero-length vectors\")\n    }\n    length(x)\n  })\n  \n  # Determine the maximum length\n  max_length <- max(lengths)\n  \n  # Check if lengths are consistent. \n  # Only allow vectors of length equal to max length or length of 1\n  if (any(lengths != max_length & lengths != 1)) {\n    stop(\"All arguments must have the same length, \n         except for vectors of length 1 which can be recycled\")\n  }\n  \n  # Use Reduce with ifelse to coalesce\n  Reduce(function(x, y) ifelse(is.na(x), y, x), args)\n}\n\n# Example usage:\nv1 <- c(NA, 2, NA, 4, NA)\nv2 <- c(1, NA, 3, NA, NA)\nv3 <- 0\n\ncoalesce_base(v1, v2, v3)\n```\n\nAgain, let's compare the speed of our function to `dplyr::coalesce` and `data.table::fcoalesce`.\n\n```{r}\nmicrobenchmark(fcoalesce(x, y, z),\n               coalesce(x, y, z), \n               coalesce_base_r(x, y, z), \n               times = 5)\n```\n\n`data.table::fcoalesce` is the clear winner when it comes to speed! Our function is almost identical in speed to `dplyr::coalesce`! \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","feed":true,"theme":"cosmo","title-block-banner":true,"title":"Base R Equivalents of dplyr Functions Part 1 - coalesce","author":"Dave Rosenman","date":"2024-05-16","categories":["R","code","tidyverse","dplyr"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}