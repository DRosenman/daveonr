[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Blog",
    "section": "",
    "text": "Base R Equivalents of dplyr Functions Part 1 - coalesce\n\n\n\n\n\n\nR\n\n\ncode\n\n\ntidyverse\n\n\ndplyr\n\n\n\n\n\n\n\n\n\nMay 16, 2024\n\n\nDave Rosenman\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nMay 16, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nMay 13, 2024\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/base-r-equivalents-of-dplyr-functions-part-1-coalesce/index.html",
    "href": "posts/base-r-equivalents-of-dplyr-functions-part-1-coalesce/index.html",
    "title": "Base R Equivalents of dplyr Functions Part 1 - coalesce",
    "section": "",
    "text": "The dplyr coalesce function is an incredibly useful function that I use often. It is similar to the SQL COALESCE function, another function that I use often. Given a set of vectors, it finds and keeps the first non NA value at each position. For example, the following code return the vector c(1, 2, 3, 4).\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\ncoalesce(c(1, NA, 3, NA), c(2, 2, 4, 4))\n\n[1] 1 2 3 4\n\n\nAt position 1, the first non-NA value is 1 (from the first vector). At position 2, the first non-NA value is 2 (from the second vector, because the value at position 2 in the first vector is NA). At position 3, the first non-NA value is 3 (from the first vector). Finally, at position 4, the first non-NA value is 4 (from the second vector, because the value at position 4 in the first vector is NA).\nThe coalesce function is not limited to two vectors. You can use as many vectors as you’d like.\n\ncoalesce(c(1, 2, NA, NA), c(3, 3, 3, NA), c(4, 4, 4, 4))\n\n[1] 1 2 3 4\n\n\nThe vectors must be of equal length or length 1. Vectors of length 1 will be recycled. The following:\n\ncoalesce(c(1, NA, NA, 5), 3)\n\n[1] 1 3 3 5\n\n\nIs equivalent to:\n\ndplyr::coalesce(c(1, NA, NA, 5), c(3, 3, 3, 3))\n\n[1] 1 3 3 5\n\n\nI most often use coalesce to replace all NA’s in a vector by a single value. For example, the following code replaces all NAs with 0:\n\ncoalesce(c(1, NA, NA, 5, 6), 0)\n\n[1] 1 0 0 5 6\n\n\nHere are two alternative ways to do the same thing.\n\nlibrary(tidyr)\nreplace_na(c(1, NA, NA, 5, 6), 0) # this function is in the tidyr package\n\n[1] 1 0 0 5 6\n\n\n\nx &lt;- c(1, NA, NA, 5, 6)\nifelse(is.na(x), 0, x)\n\n[1] 1 0 0 5 6\n\n\nOf the three options I have shown so far, I prefer coalesce and replace_na (coalesce is a more general version of replace_na; replace_na takes a vector and a single value to replace the NAs in that vector with). Let’s compare the speed of all three:\n\nset.seed(11)\nx &lt;- 1:10^7\nx[sample(1:10^7, size = 10^6, replace = FALSE)] &lt;- NA\nmicrobenchmark::microbenchmark(\n  coalesce(x, 0),\n  replace_na(x, 0),\n  ifelse(is.na(x), 0, x),\n  times = 5\n  )\n\nUnit: milliseconds\n                   expr      min       lq      mean   median       uq      max\n         coalesce(x, 0) 540.2089 560.6954 608.68458 586.1801 647.6283 708.7102\n       replace_na(x, 0)  52.6145  57.2055  62.83924  61.9616  70.5121  71.9025\n ifelse(is.na(x), 0, x) 304.8390 318.6630 371.67604 377.1181 386.3603 471.3998\n neval\n     5\n     5\n     5\n\n\nreplace_na is the fastest. I still tend to use coalesce for replacing all NAs in a vector with a single, specific value. I am the only person on my work team who uses R, but my team members use SQL and recognize the name coalesce in my code. For small to medium size vectors, each function runs super quick. Also, of the three methods above, coalesce is the most general, since it isn’t limited to the case of replacing all NAs with a single value.\nIs there a base R equivalent to dplyr::coalesce? No. But we can easily create one using just base R code.\nTo think about how we would do that, let’s start with two vectors:\n\nx &lt;- c(1, 2, NA, NA)\ny &lt;- c(2, 2, 3, NA)\ncoalesce(x, y)\n\n[1]  1  2  3 NA\n\n\nHow could we get the same results using the ifelse function? It’s simple. We return the value in y when the value in x is NA.\n\nifelse(is.na(x), y, x)\n\n[1]  1  2  3 NA\n\n\nThat’s simple enough. But what if we want to use three vectors?\n\nz &lt;- c(4, 4, 4, 4)\ncoalesce(x, y, z)\n\n[1] 1 2 3 4\n\n\nWe can start with our code from the case where we are using two vectors.\n\noutput_step_1 &lt;- ifelse(is.na(x), y, x)\n\nWhen both x and y are NA (when ifelse(is.na(x), y, x) gives us NA), we want to use what is in z. Otherwise we want to keep the the results from step 1 above.\n\nifelse(is.na(output_step_1), z, output_step_1)\n\n[1] 1 2 3 4\n\n\nThat worked! But what if we want to generalize this to any number of input vectors? We can use the base R function Reduce. For our case where we used x, y, and z we could do:\n\n Reduce(function(x, y) ifelse(is.na(x), y, x), list(x, y, z))\n\n[1] 1 2 3 4\n\n\nReduce(f, list(x, y, z)), where f is a function of two variables, is the equivalent of f(f(x, y), z). And Reduce(f, list(x, y, z, a)) is equivalent to f(f(f(x, y), z), a). The Reduce function is used to iteratively apply a function to elements of a vector or list, reducing it to a single value. It takes a function with two parameters and applies it to the first two elements of the vector, then applies the same function to the result and the next element, and so on, until all elements are combined into a single value.\nTo use Reduce to mimic coalesce(x, y, z, ...), we need to apply the logic keep_second_if_first_is_na &lt;- function(x, y) { ifelse(is.na(x), y, x) } over and over starting from left to right. We apply it first to x, y, then ap"
  }
]